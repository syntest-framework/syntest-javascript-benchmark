<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - axios/test/unit/adapters/http.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>axios/test/unit/adapters/http.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">80.04</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1036</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">80.26</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">12.16</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">var axios = require(&#039;../../../index&#039;);
var http = require(&#039;http&#039;);
var https = require(&#039;https&#039;);
var net = require(&#039;net&#039;);
var url = require(&#039;url&#039;);
var zlib = require(&#039;zlib&#039;);
var assert = require(&#039;assert&#039;);
var fs = require(&#039;fs&#039;);
var path = require(&#039;path&#039;);
var pkg = require(&#039;./../../../package.json&#039;);
var server, proxy;

describe(&#039;supports http with nodejs&#039;, function () {

  afterEach(function () {
    if (server) {
      server.close();
      server = null;
    }
    if (proxy) {
      proxy.close();
      proxy = null;
    }
    if (process.env.http_proxy) {
      delete process.env.http_proxy;
    }
    if (process.env.no_proxy) {
      delete process.env.no_proxy;
    }
  });

  it(&#039;should throw an error if the timeout property is not parsable as a number&#039;, function (done) {

    server = http.createServer(function (req, res) {
      setTimeout(function () {
        res.end();
      }, 1000);
    }).listen(4444, function () {
      var success = false, failure = false;
      var error;

      axios.get(&#039;http://localhost:4444/&#039;, {
        timeout: { strangeTimeout: 250 }
      }).then(function (res) {
        success = true;
      }).catch(function (err) {
        error = err;
        failure = true;
      });

      setTimeout(function () {
        assert.equal(success, false, &#039;request should not succeed&#039;);
        assert.equal(failure, true, &#039;request should fail&#039;);
        assert.equal(error.code, &#039;ERR_PARSE_TIMEOUT&#039;);
        assert.equal(error.message, &#039;error trying to parse `config.timeout` to int&#039;);
        done();
      }, 300);
    });
  });

  it(&#039;should parse the timeout property&#039;, function (done) {

    server = http.createServer(function (req, res) {
      setTimeout(function () {
        res.end();
      }, 1000);
    }).listen(4444, function () {
      var success = false, failure = false;
      var error;

      axios.get(&#039;http://localhost:4444/&#039;, {
        timeout: &#039;250&#039;
      }).then(function (res) {
        success = true;
      }).catch(function (err) {
        error = err;
        failure = true;
      });

      setTimeout(function () {
        assert.equal(success, false, &#039;request should not succeed&#039;);
        assert.equal(failure, true, &#039;request should fail&#039;);
        assert.equal(error.code, &#039;ECONNABORTED&#039;);
        assert.equal(error.message, &#039;timeout of 250ms exceeded&#039;);
        done();
      }, 300);
    });
  });

  it(&#039;should respect the timeout property&#039;, function (done) {

    server = http.createServer(function (req, res) {
      setTimeout(function () {
        res.end();
      }, 1000);
    }).listen(4444, function () {
      var success = false, failure = false;
      var error;

      axios.get(&#039;http://localhost:4444/&#039;, {
        timeout: 250
      }).then(function (res) {
        success = true;
      }).catch(function (err) {
        error = err;
        failure = true;
      });

      setTimeout(function () {
        assert.equal(success, false, &#039;request should not succeed&#039;);
        assert.equal(failure, true, &#039;request should fail&#039;);
        assert.equal(error.code, &#039;ECONNABORTED&#039;);
        assert.equal(error.message, &#039;timeout of 250ms exceeded&#039;);
        done();
      }, 300);
    });
  });

  it(&#039;should allow passing JSON&#039;, function (done) {
    var data = {
      firstName: &#039;Fred&#039;,
      lastName: &#039;Flintstone&#039;,
      emailAddr: &#039;fred@example.com&#039;
    };

    server = http.createServer(function (req, res) {
      res.setHeader(&#039;Content-Type&#039;, &#039;application/json&#039;);
      res.end(JSON.stringify(data));
    }).listen(4444, function () {
      axios.get(&#039;http://localhost:4444/&#039;).then(function (res) {
        assert.deepEqual(res.data, data);
        done();
      });
    });
  });

  it(&#039;should allow passing JSON with BOM&#039;, function (done) {
    var data = {
      firstName: &#039;Fred&#039;,
      lastName: &#039;Flintstone&#039;,
      emailAddr: &#039;fred@example.com&#039;
    };

    server = http.createServer(function (req, res) {
      res.setHeader(&#039;Content-Type&#039;, &#039;application/json&#039;);
      var bomBuffer = Buffer.from([0xEF, 0xBB, 0xBF])
      var jsonBuffer = Buffer.from(JSON.stringify(data));
      res.end(Buffer.concat([bomBuffer, jsonBuffer]));
    }).listen(4444, function () {
      axios.get(&#039;http://localhost:4444/&#039;).then(function (res) {
        assert.deepEqual(res.data, data);
        done();
      });
    });
  });

  it(&#039;should redirect&#039;, function (done) {
    var str = &#039;test response&#039;;

    server = http.createServer(function (req, res) {
      var parsed = url.parse(req.url);

      if (parsed.pathname === &#039;/one&#039;) {
        res.setHeader(&#039;Location&#039;, &#039;/two&#039;);
        res.statusCode = 302;
        res.end();
      } else {
        res.end(str);
      }
    }).listen(4444, function () {
      axios.get(&#039;http://localhost:4444/one&#039;).then(function (res) {
        assert.equal(res.data, str);
        assert.equal(res.request.path, &#039;/two&#039;);
        done();
      });
    });
  });

  it(&#039;should not redirect&#039;, function (done) {
    server = http.createServer(function (req, res) {
      res.setHeader(&#039;Location&#039;, &#039;/foo&#039;);
      res.statusCode = 302;
      res.end();
    }).listen(4444, function () {
      axios.get(&#039;http://localhost:4444/&#039;, {
        maxRedirects: 0,
        validateStatus: function () {
          return true;
        }
      }).then(function (res) {
        assert.equal(res.status, 302);
        assert.equal(res.headers[&#039;location&#039;], &#039;/foo&#039;);
        done();
      });
    });
  });

  it(&#039;should support max redirects&#039;, function (done) {
    var i = 1;
    server = http.createServer(function (req, res) {
      res.setHeader(&#039;Location&#039;, &#039;/&#039; + i);
      res.statusCode = 302;
      res.end();
      i++;
    }).listen(4444, function () {
      axios.get(&#039;http://localhost:4444/&#039;, {
        maxRedirects: 3
      }).catch(function (error) {
        done();
      });
    });
  });

  it(&#039;should preserve the HTTP verb on redirect&#039;, function (done) {
    server = http.createServer(function (req, res) {
      if (req.method.toLowerCase() !== &quot;head&quot;) {
        res.statusCode = 400;
        res.end();
        return;
      }

      var parsed = url.parse(req.url);
      if (parsed.pathname === &#039;/one&#039;) {
        res.setHeader(&#039;Location&#039;, &#039;/two&#039;);
        res.statusCode = 302;
        res.end();
      } else {
        res.end();
      }
    }).listen(4444, function () {
      axios.head(&#039;http://localhost:4444/one&#039;).then(function (res) {
        assert.equal(res.status, 200);
        done();
      }).catch(function (err) {
        done(err);
      });
    });
  });

  it(&#039;should support transparent gunzip&#039;, function (done) {
    var data = {
      firstName: &#039;Fred&#039;,
      lastName: &#039;Flintstone&#039;,
      emailAddr: &#039;fred@example.com&#039;
    };

    zlib.gzip(JSON.stringify(data), function (err, zipped) {

      server = http.createServer(function (req, res) {
        res.setHeader(&#039;Content-Type&#039;, &#039;application/json&#039;);
        res.setHeader(&#039;Content-Encoding&#039;, &#039;gzip&#039;);
        res.end(zipped);
      }).listen(4444, function () {
        axios.get(&#039;http://localhost:4444/&#039;).then(function (res) {
          assert.deepEqual(res.data, data);
          done();
        });
      });

    });
  });

  it(&#039;should support gunzip error handling&#039;, function (done) {
    server = http.createServer(function (req, res) {
      res.setHeader(&#039;Content-Type&#039;, &#039;application/json&#039;);
      res.setHeader(&#039;Content-Encoding&#039;, &#039;gzip&#039;);
      res.end(&#039;invalid response&#039;);
    }).listen(4444, function () {
      axios.get(&#039;http://localhost:4444/&#039;).catch(function (error) {
        done();
      });
    });
  });

  it(&#039;should support disabling automatic decompression of response data&#039;, function(done) {
    var data = &#039;Test data&#039;;

    zlib.gzip(data, function(err, zipped) {
      server = http.createServer(function(req, res) {
        res.setHeader(&#039;Content-Type&#039;, &#039;text/html;charset=utf-8&#039;);
        res.setHeader(&#039;Content-Encoding&#039;, &#039;gzip&#039;);
        res.end(zipped);
      }).listen(4444, function() {
        axios.get(&#039;http://localhost:4444/&#039;, {
          decompress: false,
          responseType: &#039;arraybuffer&#039;

        }).then(function(res) {
          assert.equal(res.data.toString(&#039;base64&#039;), zipped.toString(&#039;base64&#039;));
          done();
        });
      });
    });
  });

  it(&#039;should support UTF8&#039;, function (done) {
    var str = Array(100000).join(&#039;ж&#039;);

    server = http.createServer(function (req, res) {
      res.setHeader(&#039;Content-Type&#039;, &#039;text/html; charset=UTF-8&#039;);
      res.end(str);
    }).listen(4444, function () {
      axios.get(&#039;http://localhost:4444/&#039;).then(function (res) {
        assert.equal(res.data, str);
        done();
      });
    });
  });

  it(&#039;should support basic auth&#039;, function (done) {
    server = http.createServer(function (req, res) {
      res.end(req.headers.authorization);
    }).listen(4444, function () {
      var user = &#039;foo&#039;;
      var headers = { Authorization: &#039;Bearer 1234&#039; };
      axios.get(&#039;http://&#039; + user + &#039;@localhost:4444/&#039;, { headers: headers }).then(function (res) {
        var base64 = Buffer.from(user + &#039;:&#039;, &#039;utf8&#039;).toString(&#039;base64&#039;);
        assert.equal(res.data, &#039;Basic &#039; + base64);
        done();
      });
    });
  });

  it(&#039;should support basic auth with a header&#039;, function (done) {
    server = http.createServer(function (req, res) {
      res.end(req.headers.authorization);
    }).listen(4444, function () {
      var auth = { username: &#039;foo&#039;, password: &#039;bar&#039; };
      var headers = { AuThOrIzAtIoN: &#039;Bearer 1234&#039; }; // wonky casing to ensure caseless comparison
      axios.get(&#039;http://localhost:4444/&#039;, { auth: auth, headers: headers }).then(function (res) {
        var base64 = Buffer.from(&#039;foo:bar&#039;, &#039;utf8&#039;).toString(&#039;base64&#039;);
        assert.equal(res.data, &#039;Basic &#039; + base64);
        done();
      });
    });
  });

  it(&#039;should provides a default User-Agent header&#039;, function (done) {
    server = http.createServer(function (req, res) {
      res.end(req.headers[&#039;user-agent&#039;]);
    }).listen(4444, function () {
      axios.get(&#039;http://localhost:4444/&#039;).then(function (res) {
        assert.ok(/^axios\/[\d.]+$/.test(res.data), `User-Agent header does not match: ${res.data}`);
        done();
      });
    });
  });

  it(&#039;should allow the User-Agent header to be overridden&#039;, function (done) {
    server = http.createServer(function (req, res) {
      res.end(req.headers[&#039;user-agent&#039;]);
    }).listen(4444, function () {
      var headers = { &#039;UsEr-AgEnT&#039;: &#039;foo bar&#039; }; // wonky casing to ensure caseless comparison
      axios.get(&#039;http://localhost:4444/&#039;, { headers }).then(function (res) {
        assert.equal(res.data, &#039;foo bar&#039;);
        done();
      });
    });
  });

  it(&#039;should allow the Content-Length header to be overridden&#039;, function (done) {
    server = http.createServer(function (req, res) {
      assert.strictEqual(req.headers[&#039;content-length&#039;], &#039;42&#039;);
      res.end();
    }).listen(4444, function () {
      var headers = { &#039;CoNtEnT-lEnGtH&#039;: &#039;42&#039; }; // wonky casing to ensure caseless comparison
      axios.post(&#039;http://localhost:4444/&#039;, &#039;foo&#039;, { headers }).then(function () {
        done();
      });
    });
  });

  it(&#039;should support max content length&#039;, function (done) {
    var str = Array(100000).join(&#039;ж&#039;);

    server = http.createServer(function (req, res) {
      res.setHeader(&#039;Content-Type&#039;, &#039;text/html; charset=UTF-8&#039;);
      res.end(str);
    }).listen(4444, function () {
      var success = false, failure = false, error;

      axios.get(&#039;http://localhost:4444/&#039;, {
        maxContentLength: 2000
      }).then(function (res) {
        success = true;
      }).catch(function (err) {
        error = err;
        failure = true;
      });

      setTimeout(function () {
        assert.equal(success, false, &#039;request should not succeed&#039;);
        assert.equal(failure, true, &#039;request should fail&#039;);
        assert.equal(error.message, &#039;maxContentLength size of 2000 exceeded&#039;);
        done();
      }, 100);
    });
  });

  it(&#039;should support max content length for redirected&#039;, function (done) {
    var str = Array(100000).join(&#039;ж&#039;);

    server = http.createServer(function (req, res) {
      var parsed = url.parse(req.url);

      if (parsed.pathname === &#039;/two&#039;) {
        res.setHeader(&#039;Content-Type&#039;, &#039;text/html; charset=UTF-8&#039;);
        res.end(str);
      } else {
        res.setHeader(&#039;Location&#039;, &#039;/two&#039;);
        res.statusCode = 302;
        res.end();
      }
    }).listen(4444, function () {
      var success = false, failure = false, error;

      axios.get(&#039;http://localhost:4444/one&#039;, {
        maxContentLength: 2000
      }).then(function (res) {
        success = true;
      }).catch(function (err) {
        error = err;
        failure = true;
      });

      setTimeout(function () {
        assert.equal(success, false, &#039;request should not succeed&#039;);
        assert.equal(failure, true, &#039;request should fail&#039;);
        assert.equal(error.message, &#039;maxContentLength size of 2000 exceeded&#039;);
        done();
      }, 100);
    });
  });

  it(&#039;should support max body length&#039;, function (done) {
    var data = Array(100000).join(&#039;ж&#039;);

    server = http.createServer(function (req, res) {
      res.setHeader(&#039;Content-Type&#039;, &#039;text/html; charset=UTF-8&#039;);
      res.end();
    }).listen(4444, function () {
      var success = false, failure = false, error;

      axios.post(&#039;http://localhost:4444/&#039;, {
        data: data
      }, {
        maxBodyLength: 2000
      }).then(function (res) {
        success = true;
      }).catch(function (err) {
        error = err;
        failure = true;
      });


      setTimeout(function () {
        assert.equal(success, false, &#039;request should not succeed&#039;);
        assert.equal(failure, true, &#039;request should fail&#039;);
        assert.equal(error.message, &#039;Request body larger than maxBodyLength limit&#039;);
        done();
      }, 100);
    });
  });

  it(&#039;should support sockets&#039;, function (done) {
    // Different sockets for win32 vs darwin/linux
    var socketName = &#039;./test.sock&#039;;

    if (process.platform === &#039;win32&#039;) {
      socketName = &#039;\\\\.\\pipe\\libuv-test&#039;;
    }

    server = net.createServer(function (socket) {
      socket.on(&#039;data&#039;, function () {
        socket.end(&#039;HTTP/1.1 200 OK\r\n\r\n&#039;);
      });
    }).listen(socketName, function () {
      axios({
        socketPath: socketName,
        url: &#039;/&#039;
      })
        .then(function (resp) {
          assert.equal(resp.status, 200);
          assert.equal(resp.statusText, &#039;OK&#039;);
          done();
        })
        .catch(function (error) {
          assert.ifError(error);
          done();
        });
    });
  });

  it(&#039;should support streams&#039;, function (done) {
    server = http.createServer(function (req, res) {
      req.pipe(res);
    }).listen(4444, function () {
      axios.post(&#039;http://localhost:4444/&#039;,
        fs.createReadStream(__filename), {
          responseType: &#039;stream&#039;
        }).then(function (res) {
          var stream = res.data;
          var string = &#039;&#039;;
          stream.on(&#039;data&#039;, function (chunk) {
            string += chunk.toString(&#039;utf8&#039;);
          });
          stream.on(&#039;end&#039;, function () {
            assert.equal(string, fs.readFileSync(__filename, &#039;utf8&#039;));
            done();
          });
        });
    });
  });

  it(&#039;should pass errors for a failed stream&#039;, function (done) {
    var notExitPath = path.join(__dirname, &#039;does_not_exist&#039;);

    server = http.createServer(function (req, res) {
      req.pipe(res);
    }).listen(4444, function () {
      axios.post(&#039;http://localhost:4444/&#039;,
        fs.createReadStream(notExitPath)
      ).then(function (res) {
        assert.fail();
      }).catch(function (err) {
        assert.equal(err.message, `ENOENT: no such file or directory, open \&#039;${notExitPath}\&#039;`);
        done();
      });
    });
  });

  it(&#039;should support buffers&#039;, function (done) {
    var buf = Buffer.alloc(1024, &#039;x&#039;); // Unsafe buffer &lt; Buffer.poolSize (8192 bytes)
    server = http.createServer(function (req, res) {
      assert.equal(req.headers[&#039;content-length&#039;], buf.length.toString());
      req.pipe(res);
    }).listen(4444, function () {
      axios.post(&#039;http://localhost:4444/&#039;,
        buf, {
          responseType: &#039;stream&#039;
        }).then(function (res) {
          var stream = res.data;
          var string = &#039;&#039;;
          stream.on(&#039;data&#039;, function (chunk) {
            string += chunk.toString(&#039;utf8&#039;);
          });
          stream.on(&#039;end&#039;, function () {
            assert.equal(string, buf.toString());
            done();
          });
        });
    });
  });

  it(&#039;should support HTTP proxies&#039;, function (done) {
    server = http.createServer(function (req, res) {
      res.setHeader(&#039;Content-Type&#039;, &#039;text/html; charset=UTF-8&#039;);
      res.end(&#039;12345&#039;);
    }).listen(4444, function () {
      proxy = http.createServer(function (request, response) {
        var parsed = url.parse(request.url);
        var opts = {
          host: parsed.hostname,
          port: parsed.port,
          path: parsed.path
        };

        http.get(opts, function (res) {
          var body = &#039;&#039;;
          res.on(&#039;data&#039;, function (data) {
            body += data;
          });
          res.on(&#039;end&#039;, function () {
            response.setHeader(&#039;Content-Type&#039;, &#039;text/html; charset=UTF-8&#039;);
            response.end(body + &#039;6789&#039;);
          });
        });

      }).listen(4000, function () {
        axios.get(&#039;http://localhost:4444/&#039;, {
          proxy: {
            host: &#039;localhost&#039;,
            port: 4000
          }
        }).then(function (res) {
          assert.equal(res.data, &#039;123456789&#039;, &#039;should pass through proxy&#039;);
          done();
        });
      });
    });
  });

  it(&#039;should support HTTPS proxies&#039;, function (done) {
    var options = {
      key: fs.readFileSync(path.join(__dirname, &#039;key.pem&#039;)),
      cert: fs.readFileSync(path.join(__dirname, &#039;cert.pem&#039;))
    };

    server = https.createServer(options, function (req, res) {
      res.setHeader(&#039;Content-Type&#039;, &#039;text/html; charset=UTF-8&#039;);
      res.end(&#039;12345&#039;);
    }).listen(4444, function () {
      proxy = https.createServer(options, function (request, response) {
        var parsed = url.parse(request.url);
        var opts = {
          host: parsed.hostname,
          port: parsed.port,
          path: parsed.path,
          protocol: parsed.protocol,
          rejectUnauthorized: false
        };

        https.get(opts, function (res) {
          var body = &#039;&#039;;
          res.on(&#039;data&#039;, function (data) {
            body += data;
          });
          res.on(&#039;end&#039;, function () {
            response.setHeader(&#039;Content-Type&#039;, &#039;text/html; charset=UTF-8&#039;);
            response.end(body + &#039;6789&#039;);
          });
        });
      }).listen(4000, function () {
        axios.get(&#039;https://localhost:4444/&#039;, {
          proxy: {
            host: &#039;localhost&#039;,
            port: 4000,
            protocol: &#039;https&#039;
          },
          httpsAgent: new https.Agent({
            rejectUnauthorized: false
          })
        }).then(function (res) {
          assert.equal(res.data, &#039;123456789&#039;, &#039;should pass through proxy&#039;);
          done();
        }).catch(function (err) {
          assert.fail(err);
          done()
        });
      });
    });
  });

  it(&#039;should not pass through disabled proxy&#039;, function (done) {
    // set the env variable
    process.env.http_proxy = &#039;http://does-not-exists.example.com:4242/&#039;;

    server = http.createServer(function (req, res) {
      res.setHeader(&#039;Content-Type&#039;, &#039;text/html; charset=UTF-8&#039;);
      res.end(&#039;123456789&#039;);
    }).listen(4444, function () {
      axios.get(&#039;http://localhost:4444/&#039;, {
        proxy: false
      }).then(function (res) {
        assert.equal(res.data, &#039;123456789&#039;, &#039;should not pass through proxy&#039;);
        done();
      });
    });
  });

  it(&#039;should support proxy set via env var&#039;, function (done) {
    server = http.createServer(function (req, res) {
      res.setHeader(&#039;Content-Type&#039;, &#039;text/html; charset=UTF-8&#039;);
      res.end(&#039;4567&#039;);
    }).listen(4444, function () {
      proxy = http.createServer(function (request, response) {
        var parsed = url.parse(request.url);
        var opts = {
          host: parsed.hostname,
          port: parsed.port,
          path: parsed.path
        };

        http.get(opts, function (res) {
          var body = &#039;&#039;;
          res.on(&#039;data&#039;, function (data) {
            body += data;
          });
          res.on(&#039;end&#039;, function () {
            response.setHeader(&#039;Content-Type&#039;, &#039;text/html; charset=UTF-8&#039;);
            response.end(body + &#039;1234&#039;);
          });
        });

      }).listen(4000, function () {
        // set the env variable
        process.env.http_proxy = &#039;http://localhost:4000/&#039;;

        axios.get(&#039;http://localhost:4444/&#039;).then(function (res) {
          assert.equal(res.data, &#039;45671234&#039;, &#039;should use proxy set by process.env.http_proxy&#039;);
          done();
        });
      });
    });
  });

  it(&#039;should support HTTPS proxy set via env var&#039;, function (done) {
    var options = {
      key: fs.readFileSync(path.join(__dirname, &#039;key.pem&#039;)),
      cert: fs.readFileSync(path.join(__dirname, &#039;cert.pem&#039;))
    };

    server = https.createServer(options, function (req, res) {
      res.setHeader(&#039;Content-Type&#039;, &#039;text/html; charset=UTF-8&#039;);
      res.end(&#039;12345&#039;);
    }).listen(4444, function () {
      proxy = https.createServer(options, function (request, response) {
        var parsed = url.parse(request.url);
        var opts = {
          host: parsed.hostname,
          port: parsed.port,
          path: parsed.path,
          protocol: parsed.protocol,
          rejectUnauthorized: false
        };

        https.get(opts, function (res) {
          var body = &#039;&#039;;
          res.on(&#039;data&#039;, function (data) {
            body += data;
          });
          res.on(&#039;end&#039;, function () {
            response.setHeader(&#039;Content-Type&#039;, &#039;text/html; charset=UTF-8&#039;);
            response.end(body + &#039;6789&#039;);
          });
        });
      }).listen(4000, function () {
        process.env.https_proxy = &#039;https://localhost:4000/&#039;;

        axios.get(&#039;https://localhost:4444/&#039;, {
          httpsAgent: new https.Agent({
            rejectUnauthorized: false
          })
        }).then(function (res) {
          assert.equal(res.data, &#039;123456789&#039;, &#039;should pass through proxy&#039;);
          done();
        }).catch(function (err) {
          assert.fail(err);
          done()
        }).finally(function () {
          process.env.https_proxy = &#039;&#039;
        });
      });
    });
  });

  it(&#039;should not use proxy for domains in no_proxy&#039;, function (done) {
    server = http.createServer(function (req, res) {
      res.setHeader(&#039;Content-Type&#039;, &#039;text/html; charset=UTF-8&#039;);
      res.end(&#039;4567&#039;);
    }).listen(4444, function () {
      proxy = http.createServer(function (request, response) {
        var parsed = url.parse(request.url);
        var opts = {
          host: parsed.hostname,
          port: parsed.port,
          path: parsed.path
        };

        http.get(opts, function (res) {
          var body = &#039;&#039;;
          res.on(&#039;data&#039;, function (data) {
            body += data;
          });
          res.on(&#039;end&#039;, function () {
            response.setHeader(&#039;Content-Type&#039;, &#039;text/html; charset=UTF-8&#039;);
            response.end(body + &#039;1234&#039;);
          });
        });

      }).listen(4000, function () {
        // set the env variable
        process.env.http_proxy = &#039;http://localhost:4000/&#039;;
        process.env.no_proxy = &#039;foo.com, localhost,bar.net , , quix.co&#039;;

        axios.get(&#039;http://localhost:4444/&#039;).then(function (res) {
          assert.equal(res.data, &#039;4567&#039;, &#039;should not use proxy for domains in no_proxy&#039;);
          done();
        });
      });
    });
  });

  it(&#039;should use proxy for domains not in no_proxy&#039;, function (done) {
    server = http.createServer(function (req, res) {
      res.setHeader(&#039;Content-Type&#039;, &#039;text/html; charset=UTF-8&#039;);
      res.end(&#039;4567&#039;);
    }).listen(4444, function () {
      proxy = http.createServer(function (request, response) {
        var parsed = url.parse(request.url);
        var opts = {
          host: parsed.hostname,
          port: parsed.port,
          path: parsed.path
        };

        http.get(opts, function (res) {
          var body = &#039;&#039;;
          res.on(&#039;data&#039;, function (data) {
            body += data;
          });
          res.on(&#039;end&#039;, function () {
            response.setHeader(&#039;Content-Type&#039;, &#039;text/html; charset=UTF-8&#039;);
            response.end(body + &#039;1234&#039;);
          });
        });

      }).listen(4000, function () {
        // set the env variable
        process.env.http_proxy = &#039;http://localhost:4000/&#039;;
        process.env.no_proxy = &#039;foo.com, ,bar.net , quix.co&#039;;

        axios.get(&#039;http://localhost:4444/&#039;).then(function (res) {
          assert.equal(res.data, &#039;45671234&#039;, &#039;should use proxy for domains not in no_proxy&#039;);
          done();
        });
      });
    });
  });

  it(&#039;should support HTTP proxy auth&#039;, function (done) {
    server = http.createServer(function (req, res) {
      res.end();
    }).listen(4444, function () {
      proxy = http.createServer(function (request, response) {
        var parsed = url.parse(request.url);
        var opts = {
          host: parsed.hostname,
          port: parsed.port,
          path: parsed.path
        };
        var proxyAuth = request.headers[&#039;proxy-authorization&#039;];

        http.get(opts, function (res) {
          var body = &#039;&#039;;
          res.on(&#039;data&#039;, function (data) {
            body += data;
          });
          res.on(&#039;end&#039;, function () {
            response.setHeader(&#039;Content-Type&#039;, &#039;text/html; charset=UTF-8&#039;);
            response.end(proxyAuth);
          });
        });

      }).listen(4000, function () {
        axios.get(&#039;http://localhost:4444/&#039;, {
          proxy: {
            host: &#039;localhost&#039;,
            port: 4000,
            auth: {
              username: &#039;user&#039;,
              password: &#039;pass&#039;
            }
          }
        }).then(function (res) {
          var base64 = Buffer.from(&#039;user:pass&#039;, &#039;utf8&#039;).toString(&#039;base64&#039;);
          assert.equal(res.data, &#039;Basic &#039; + base64, &#039;should authenticate to the proxy&#039;);
          done();
        });
      });
    });
  });

  it(&#039;should support proxy auth from env&#039;, function (done) {
    server = http.createServer(function (req, res) {
      res.end();
    }).listen(4444, function () {
      proxy = http.createServer(function (request, response) {
        var parsed = url.parse(request.url);
        var opts = {
          host: parsed.hostname,
          port: parsed.port,
          path: parsed.path
        };
        var proxyAuth = request.headers[&#039;proxy-authorization&#039;];

        http.get(opts, function (res) {
          var body = &#039;&#039;;
          res.on(&#039;data&#039;, function (data) {
            body += data;
          });
          res.on(&#039;end&#039;, function () {
            response.setHeader(&#039;Content-Type&#039;, &#039;text/html; charset=UTF-8&#039;);
            response.end(proxyAuth);
          });
        });

      }).listen(4000, function () {
        process.env.http_proxy = &#039;http://user:pass@localhost:4000/&#039;;

        axios.get(&#039;http://localhost:4444/&#039;).then(function (res) {
          var base64 = Buffer.from(&#039;user:pass&#039;, &#039;utf8&#039;).toString(&#039;base64&#039;);
          assert.equal(res.data, &#039;Basic &#039; + base64, &#039;should authenticate to the proxy set by process.env.http_proxy&#039;);
          done();
        });
      });
    });
  });

  it(&#039;should support proxy auth with header&#039;, function (done) {
    server = http.createServer(function (req, res) {
      res.end();
    }).listen(4444, function () {
      proxy = http.createServer(function (request, response) {
        var parsed = url.parse(request.url);
        var opts = {
          host: parsed.hostname,
          port: parsed.port,
          path: parsed.path
        };
        var proxyAuth = request.headers[&#039;proxy-authorization&#039;];

        http.get(opts, function (res) {
          var body = &#039;&#039;;
          res.on(&#039;data&#039;, function (data) {
            body += data;
          });
          res.on(&#039;end&#039;, function () {
            response.setHeader(&#039;Content-Type&#039;, &#039;text/html; charset=UTF-8&#039;);
            response.end(proxyAuth);
          });
        });

      }).listen(4000, function () {
        axios.get(&#039;http://localhost:4444/&#039;, {
          proxy: {
            host: &#039;localhost&#039;,
            port: 4000,
            auth: {
              username: &#039;user&#039;,
              password: &#039;pass&#039;
            }
          },
          headers: {
            &#039;Proxy-Authorization&#039;: &#039;Basic abc123&#039;
          }
        }).then(function (res) {
          var base64 = Buffer.from(&#039;user:pass&#039;, &#039;utf8&#039;).toString(&#039;base64&#039;);
          assert.equal(res.data, &#039;Basic &#039; + base64, &#039;should authenticate to the proxy&#039;);
          done();
        });
      });
    });
  });

  it(&#039;should support cancel&#039;, function (done) {
    var source = axios.CancelToken.source();
    server = http.createServer(function (req, res) {
      // call cancel() when the request has been sent, but a response has not been received
      source.cancel(&#039;Operation has been canceled.&#039;);
    }).listen(4444, function () {
      axios.get(&#039;http://localhost:4444/&#039;, {
        cancelToken: source.token
      }).catch(function (thrown) {
        assert.ok(thrown instanceof axios.Cancel, &#039;Promise must be rejected with a Cancel object&#039;);
        assert.equal(thrown.message, &#039;Operation has been canceled.&#039;);
        done();
      });
    });
  });

  it(&#039;should combine baseURL and url&#039;, function (done) {
    server = http.createServer(function (req, res) {
      res.end();
    }).listen(4444, function () {
      axios.get(&#039;/foo&#039;, {
        baseURL: &#039;http://localhost:4444/&#039;,
      }).then(function (res) {
        assert.equal(res.config.baseURL, &#039;http://localhost:4444/&#039;);
        assert.equal(res.config.url, &#039;/foo&#039;);
        done();
      });
    });
  });

  it(&#039;should supply a user-agent if one is not specified&#039;, function (done) {
    server = http.createServer(function (req, res) {
      assert.equal(req.headers[&quot;user-agent&quot;], &#039;axios/&#039; + pkg.version);
      res.end();
    }).listen(4444, function () {
      axios.get(&#039;http://localhost:4444/&#039;
      ).then(function (res) {
        done();
      });
    });
  });

  it(&#039;should omit a user-agent if one is explicitly disclaimed&#039;, function (done) {
    server = http.createServer(function (req, res) {
      assert.equal(&quot;user-agent&quot; in req.headers, false);
      assert.equal(&quot;User-Agent&quot; in req.headers, false);
      res.end();
    }).listen(4444, function () {
      axios.get(&#039;http://localhost:4444/&#039;, {
        headers: {
          &quot;User-Agent&quot;: null
        }
      }
      ).then(function (res) {
        done();
      });
    });
  });

  it(&#039;should throw an error if http server that aborts a chunked request&#039;, function (done) {
    server = http.createServer(function (req, res) {
      res.writeHead(200, { &#039;Content-Type&#039;: &#039;text/plain&#039; });
      res.write(&#039;chunk 1&#039;);
      setTimeout(function () {
        res.write(&#039;chunk 2&#039;);
      }, 100);
      setTimeout(function() {
        res.destroy();
      }, 200);
    }).listen(4444, function () {
      var success = false, failure = false;
      var error;

      axios.get(&#039;http://localhost:4444/aborted&#039;, {
        timeout: 500
      }).then(function (res) {
        success = true;
      }).catch(function (err) {
        error = err;
        failure = true;
      }).finally(function () {
        assert.strictEqual(success, false, &#039;request should not succeed&#039;);
        assert.strictEqual(failure, true, &#039;request should fail&#039;);
        assert.strictEqual(error.code, &#039;ERR_REQUEST_ABORTED&#039;);
        assert.strictEqual(error.message, &#039;error request aborted&#039;);
        done();
      });
    });
  });

});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
